package com.marklogic.mgmt.resource.tasks;

import com.marklogic.mgmt.ManageClient;
import com.marklogic.mgmt.SaveReceipt;
import com.marklogic.mgmt.resource.AbstractResourceManager;
import com.marklogic.mgmt.resource.requests.RequestManager;
import com.marklogic.rest.util.Fragment;

import java.util.ArrayList;
import java.util.List;

/**
 * The "groupName" property of this class corresponds to the "group-id" querystring parameter. It's called
 * "groupName" because "group-id" is misleading - it's a name, not an ID.
 */
public class TaskManager extends AbstractResourceManager {

	private String groupName = "Default";

	public TaskManager(ManageClient client) {
		super(client);
	}

	public TaskManager(ManageClient client, String groupName) {
		super(client);
		this.groupName = groupName;
	}

	/**
	 * Tasks are tricky because their unique field is "task-id", but that's generated by MarkLogic - it's not expected
	 * to be in a payload. So this method has to do some extra work to determine what the task-id is for the given
	 * payload. It does so by looking for an existing task with the same task-path and task-database as what's in the
	 * given payload. If one exists, then the task-id from the existing task is used. Otherwise, null is returned.
	 *
	 * @param payload
	 * @return
	 */
	@Override
	protected String getResourceId(String payload) {
		final String taskId = payloadParser.getPayloadFieldValue(payload, "task-id", false);
		if (taskId != null) {
			return taskId;
		}

		final String taskPath = payloadParser.getPayloadFieldValue(payload, "task-path");
		final String taskDatabase = payloadParser.getPayloadFieldValue(payload, "task-database", false);

		final String xpath = taskDatabase != null ?
			format("/t:tasks-default-list/t:list-items/t:list-item[t:task-path = '%s' and t:task-database = '%s']/t:idref", taskPath, taskDatabase) :
			format("/t:tasks-default-list/t:list-items/t:list-item[t:task-path = '%s']/t:idref", taskPath);

		return getAsXml().getElementValue(xpath);
	}

	@Override
	public String getResourcesPath() {
		return appendGroupId(super.getResourcesPath());
	}

	protected String appendGroupId(String path) {
		if (groupName != null) {
			if (path.contains("?")) {
				return path + "&group-id=" + groupName;
			}
			return path + "?group-id=" + groupName;
		}
		return path;
	}

	@Override
	public String getResourcePath(String resourceNameOrId, String... resourceUrlParams) {
		return super.getResourcesPath() + "/" + getTaskIdForTaskPath(resourceNameOrId);
	}

	@Override
	protected String[] getUpdateResourceParams(String payload) {
		List<String> params = new ArrayList<>();
		params.add("group-id");
		params.add(groupName);
		return params.toArray(new String[]{});
	}

	@Override
	protected String getIdFieldName() {
		return "task-id";
	}

	/**
	 * Previously, this method only accepted a task-path because that was previously used as the unique ID for a task.
	 * But since two or more tasks can have the same task-path, this class now uses task-id. To preserve backwards
	 * compatibility then, this method accepts a task-path or a task-id.
	 *
	 * @param taskPathOrTaskId
	 * @return
	 */
	public String getTaskIdForTaskPath(String taskPathOrTaskId) {
		Fragment f = getAsXml();
		String xpath = "/t:tasks-default-list/t:list-items/t:list-item[t:task-path = '%s' or t:idref = '%s']/t:idref";
		xpath = String.format(xpath, taskPathOrTaskId, taskPathOrTaskId);
		String id = f.getElementValue(xpath);
		if (id == null) {
			throw new RuntimeException("Could not find a scheduled task with a task-path or task-id of: " + taskPathOrTaskId);
		}
		return id;
	}

	/**
	 * This accounts for an existing task with either task-path or task-id equal to the given resourceNameOrId.
	 * This preserves backwards compatibility to when this class used task-path as the ID property.
	 *
	 * @param resourceNameOrId
	 * @param resourceUrlParams
	 * @return
	 */
	@Override
	public boolean exists(String resourceNameOrId, String... resourceUrlParams) {
		if (logger.isInfoEnabled()) {
			logger.info("Checking for existence of resource: " + resourceNameOrId);
		}
		Fragment f = getAsXml();
		return f.elementExists(format(
			"/t:tasks-default-list/t:list-items/t:list-item[t:task-path = '%s' or t:idref = '%s']",
			resourceNameOrId, resourceNameOrId));
	}

	/**
	 * When a task is being created, its resourceId - its task-id - will always be null because MarkLogic generates it.
	 * This method only needs the resourceId for logging purposes. So it's overridden so that the task-path can be used
	 * as the resourceId so that the logging is more useful.
	 *
	 * @param payload
	 * @param resourceId
	 * @return
	 */
	@Override
	protected SaveReceipt createNewResource(String payload, String resourceId) {
		final String taskPath = payloadParser.getPayloadFieldValue(payload, "task-path", false);
		return super.createNewResource(payload, taskPath);
	}

	public List<String> getTaskPaths() {
		return getAsXml().getListItemValues("task-path");
	}

	public void disableAllTasks() {
		for (String id : getAsXml().getListItemIdRefs()) {
			disableTask(id);
		}
	}

	public void enableAllTasks() {
		for (String id : getAsXml().getListItemIdRefs()) {
			enableTask(id);
		}
	}

	public void disableTask(String taskId) {
		String json = format("{\"task-id\":\"%s\", \"task-enabled\":false}", taskId);
		String path = appendGroupId(super.getResourcesPath() + "/" + taskId + "/properties");
		putPayload(getManageClient(), path, json);
	}

	public void enableTask(String taskId) {
		String json = format("{\"task-id\":\"%s\", \"task-enabled\":true}", taskId);
		String path = appendGroupId(super.getResourcesPath() + "/" + taskId + "/properties");
		putPayload(getManageClient(), path, json);
	}

	public void deleteAllTasks() {
		deleteAllScheduledTasks();
	}

	public void deleteTaskWithPath(String taskPath) {
		String json = format("{\"task-path\":\"%s\"}", taskPath);
		delete(json, "group-id", groupName);
	}

	public String getTaskId(String taskPath) {
		return getAsXml().getElementValue(format(
			"/t:tasks-default-list/t:list-items/t:list-item[t:task-path = '%s']/t:idref", taskPath)
		);
	}

	public void deleteAllScheduledTasks() {
		for (String id : getAsXml().getListItemIdRefs()) {
			deleteAtPath(appendGroupId(super.getResourcesPath() + "/" + id));
		}
	}

	public void waitForTasksToComplete(String group, int retryInMilliseconds) {
		Fragment servers = getManageClient().getXml("/manage/v2/task-servers");
		String taskServerId = servers.getElementValue(format("//ts:list-item[ts:groupnameref = '%s']/ts:idref", group));
		if (taskServerId == null) {
			logger.warn(format("Could not find task server ID for group %s, so not waiting for tasks to complete", group));
			return;
		}
		RequestManager mgr = new RequestManager(getManageClient());
		if (logger.isInfoEnabled()) {
			logger.info("Waiting for tasks to complete on task server");
		}
		int count = mgr.getRequestCountForRelationId(taskServerId);
		while (count > 0) {
			if (logger.isInfoEnabled()) {
				logger.info("Waiting for tasks to complete on task server, count: " + count);
			}
			try {
				Thread.sleep(retryInMilliseconds);
			} catch (InterruptedException e) {
			}
			count = mgr.getRequestCountForRelationId(taskServerId);
		}
		if (logger.isInfoEnabled()) {
			logger.info("Finished waiting for tasks to complete on task server");
		}
	}

	public void setGroupName(String groupName) {
		this.groupName = groupName;
	}

	public String getGroupName() {
		return groupName;
	}
}
